name: Jaime-Frontend

on:
  workflow_dispatch: {}

  push:
    branches:
      - "release/*"
      - "develop/*"
      - main  # remove
    tags:
      - "v*.*.*"

  pull_request:
    branches:
      - main

permissions:
  id-token: write
  contents: read

env:
  OPENAPI_FOLDER: docs
  # AWS_ECR_ARN_ID: "149653749155"     # Edit
  # AWS_ARN_ID_DEV: "813070094344"
  # AWS_ARN_ID_STG: "132772905962"
  # AWS_ARN_ID_PRD: "542585190769"
  # AWS_STS_USER: AssumeRoleForPipeline  # Edit
  # AZ_SUBSCRIPTION_ID: c649caeb-f619-4f45-b199-48207ab3731e
  # AZ_CLIENT_ID: 3ba228ea-f261-4a76-8dd8-3b28e0d6730e
  # AZ_TENANT_ID: 2840389b-0f81-496f-b742-ac794a5da61e
  AWS_ECR_ARN_ID: "227295996532"    
  AWS_ARN_ID_DEV: "227295996532"  
  AWS_STS_USER: jaime-role
  AZ_SUBSCRIPTION_ID: 618a2bb0-72e3-4d01-beef-27ad0d0f77d8
  AZ_CLIENT_ID: 6da1fa95-ac00-4e48-8a40-7b9483f48e83
  AZ_TENANT_ID: 13ee1f99-2c19-4ffe-8479-7229725bc499
  AZ_DEVOPS_PROJ: JAIME-vebuin
  AZ_DEVOPS_ORG: https://dev.azure.com/hariom0502
  AZ_DEVOPS_BRANCH: main
  AZ_DEVOPS_APPROVAL_PIPELINE_NAME: Deploy_Request
  AWS_REGION: us-east-1
  AWS_REGION_1: ap-northeast-1
  ECR_REPO: node-poc
  CLUSTER_NAME: jaime-poc
  NODE_DEPLOYMENT_FILE: deployment.yaml
  ZAP_DEPLOYMENT_FILE: zap-deployment.yaml
  NAMESPACE_1: jaime-poc-2285
  NAMESPACE_2: jaime-poc-6460
  APP_DIR: ./    # folder containing Dockerfile

jobs:
  Linting_and_Formatting:
    runs-on: ubuntu-latest
    environment: production
    continue-on-error: true
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 22

      - name: Install dependencies
        run: npm run start

      - name: Run ESLint (linting)
        run: npm run lint

      - name: Run Prettier (formatting check)
        run: npm run format:check

  Unit_Testing:
    runs-on: ubuntu-latest
    environment: production
    needs: Linting_and_Formatting
    continue-on-error: true
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 22

      - name: Install dependencies
        run: npm run start

      - name: Run Unit Tests
        run: npm run test


  # OWASPZAP:
    # runs-on: ["jccai"]
    # environment: production
    # steps:
    #   - name: Checkout repository
    #     uses: actions/checkout@v4

    #   - name: Setup Node.js
    #     uses: actions/setup-node@v4
    #     with:
    #       node-version: 20

    #   - name: Install dependencies
    #     run: npm ci

    #   - name: Run ESLint (linting)
    #     run: npx eslint . --max-warnings=0

    #   - name: Run Prettier (formatting check)
    #     run: npx prettier --check .

  license_scanning:
   runs-on: ubuntu-latest
   needs: Unit_Testing
   continue-on-error: true
   steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: 22

    - name: Install dependencies
      run: npm install

    - name: Install license-checker
      run: npm install -g license-checker

    - name: Run license-checker and generate report
      run: license-checker --json > license_report.json

    - name: Upload license report artifact
      uses: actions/upload-artifact@v4
      with:
        name: nodejs_license_report
        path: license_report.json

  build:
    environment: "build"
    runs-on: ubuntu-latest
    needs: license_scanning
    outputs:
      # image_name: ${{ steps.image_name.outputs.result }}
      aws_assume_role: ${{ steps.build.outputs.aws_assume_role }}
      aws_arn_id: ${{ steps.build.outputs.aws_arn_id }}
      aws_region: ${{ steps.build.outputs.aws_region }}
      az_subscription_id: ${{ steps.build.outputs.az_subscription_id }}
      docker_tag: ${{ steps.build.outputs.docker_tag }}
      environment: ${{ steps.build.outputs.environment }}
      environment_display: ${{ steps.build.outputs.environment_display }}
      envFile: ${{ steps.build.outputs.envFile}}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      # - name: Execute build for ${{ steps.image_name.outputs.result }}
      - name: Execute build for Jaime-Frontend
        uses: ./.github/actions/build
        id: build
        with:
          # working-directory: ${{ matrix.files }}
          AWS_ECR_ARN_ID: ${{ env.AWS_ECR_ARN_ID }}
          AWS_REGION: ap-northeast-1
          AWS_STS_USER: ${{ env.AWS_STS_USER }}
          IMAGE_NAME: jaime-frontend


          #DEV
          IS_DEV: ${{ github.ref_type == 'branch' && startsWith(github.ref_name, 'develop') }}
          AWS_ARN_ID_DEV: ${{ env.AWS_ARN_ID_DEV }}
          AZ_SUBSCRIPTION_ID_DEV: ${{ env.AZ_SUBSCRIPTION_ID }}

          #STG
          IS_STG: ${{ github.ref_type == 'branch' && startsWith(github.ref_name, 'release') }}
          AWS_ARN_ID_STG: ${{ env.AWS_ARN_ID_STG }}
          AZ_SUBSCRIPTION_ID_STG: ${{ env.AZ_SUBSCRIPTION_ID }}

          #PRD
          IS_PROD: ${{ github.ref_type == 'tag' && !contains(github.ref_name, '-rc') || github.event_name == 'pull_request' }}
          AWS_ARN_ID_PRD: ${{ env.AWS_ARN_ID_PRD }}
          AZ_SUBSCRIPTION_ID_PRD: ${{ env.AZ_SUBSCRIPTION_ID }}

      - name: Save Docker image to artifact
        shell: bash
        run: |
          DOCKER_TAG=$(echo "${{ steps.build.outputs.docker_tag }}" | head -n1)
          echo "Saving Docker image: $DOCKER_TAG"
          docker save "$DOCKER_TAG" -o /tmp/docker-image.tar
          ls -lh /tmp/docker-image.tar

      - name: Upload Docker image artifact
        uses: actions/upload-artifact@v4
        with:
          name: docker-image-${{ github.run_id }}
          path: /tmp/docker-image.tar
          retention-days: 1

  request_deployment_approval:
    needs: ["build"]
    environment: "build"
    continue-on-error: true
    runs-on: ubuntu-latest
    if: needs.build.outputs.environment == 'production' && github.event_name != 'pull_request'
    steps:
      - uses: actions/checkout@v3

      - name: Deployment Approval Request
        uses: ./.github/actions/request_deployment_approval
        id: deployment_approval
        with:
          devOpsProj: ${{ env.AZ_DEVOPS_PROJ }}
          devOpsOrg: ${{ env.AZ_DEVOPS_ORG }}
          devOpsBranch: ${{ env.AZ_DEVOPS_BRANCH }}
          devOpsPipelineName: ${{ env.AZ_DEVOPS_APPROVAL_PIPELINE_NAME }}
          environment: ${{ needs.build.outputs.environment }}
          clientId: ${{ env.AZ_CLIENT_ID }}
          tenantId: ${{ env.AZ_TENANT_ID}}
          subscriptionId: ${{ env.AZ_SUBSCRIPTION_ID }}
          patKeyvault: JERA-Terraform-KeyVault
          patKeyvaultSecrets: AZDO-PAT,GITHUB-PAT


  push_to_ecr:
    environment: "build"
    runs-on: ubuntu-latest
    needs: ["build","request_deployment_approval"]
    if: ${{ !failure() && !cancelled() && github.event_name != 'pull_request' }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Download Docker image artifact
        uses: actions/download-artifact@v4
        with:
          name: docker-image-${{ github.run_id }}
          path: /tmp

      - name: Load Docker image
        shell: bash
        run: |
          echo "Loading Docker image from artifact..."
          docker load -i /tmp/docker-image.tar
          echo "âœ… Docker image loaded successfully"

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v3
        with:
          role-to-assume: ${{ needs.build.outputs.aws_assume_role }}
          aws-region: ${{ needs.build.outputs.aws_region }}

      - name: Verify AWS credentials
        shell: bash
        run: aws sts get-caller-identity

      - name: Login to Amazon ECR
        shell: bash
        run: |
          aws ecr get-login-password --region ${{ needs.build.outputs.aws_region }} | \
          docker login --username AWS --password-stdin \
          ${{ env.AWS_ECR_ARN_ID }}.dkr.ecr.${{ needs.build.outputs.aws_region }}.amazonaws.com

      - name: Push Docker image to ECR
        shell: bash
        run: |
          echo "ðŸš€ Pushing Docker images to ECR..."
          echo "${{ needs.build.outputs.docker_tag }}" | while read -r TAG; do
            if [ ! -z "$TAG" ]; then
              echo "Pushing: $TAG"
              docker push "$TAG"
            fi
          done
          echo "âœ… All images pushed to ECR successfully"
    
  # push_to_ecr:
  #   needs: build_and_scan
  #   runs-on: ubuntu-latest
  #   environment: production
  #   steps:
  #   # 1. Configure AWS credentials
  #   - name: Configure AWS credentials
  #     uses: aws-actions/configure-aws-credentials@v4
  #     with:
  #       aws-region: ${{ secrets.AWS_REGION }}
  #       role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
    
  #   # 2. Login to Amazon ECR
  #   - name: Login to Amazon ECR
  #     id: login-ecr
  #     uses: aws-actions/amazon-ecr-login@v2
    
  #   # 3. Checkout code (needed if your Dockerfile is in repo)
  #   - name: Checkout
  #     uses: actions/checkout@v4
    
  #   # 4. Set up metadata for tags (commit SHA + latest)
  #   - name: Docker meta
  #     id: meta
  #     uses: docker/metadata-action@v5
  #     with:
  #       images: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com/jaime-ci-poc
  #       tags: |
  #         type=sha,format=short
  #         type=raw,value=latest
    
  #   # 5. Build and push to ECR
  #   - name: Build and push
  #     uses: docker/build-push-action@v6
  #     with:
  #       context: .
  #       push: true
  #       tags: ${{ steps.meta.outputs.tags }}

 
  zap_scan:
      # Deploy to EKS and run ZAP after image is pushed
      runs-on: ubuntu-latest
      needs: push_to_ecr
      steps:
        - name: Checkout source code (for manifests and zap files)
          uses: actions/checkout@v4
    
        # - name: Configure AWS credentials (same role as push)
        #   uses: aws-actions/configure-aws-credentials@v4
        #   with:
        #     role-to-assume: ${{ needs.build.outputs.aws_assume_role }}
        #     aws-region: ${{ needs.build.outputs.aws_region }}

        - name: Configure AWS credentials
          uses: aws-actions/configure-aws-credentials@v4
          with:
            aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
            aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
            aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
            aws-region: ap-northeast-1

        - name: Login to Amazon ECR
          id: login-ecr
          uses: aws-actions/amazon-ecr-login@v2
  
        - name: Build and push Docker image to ECR
          id: build-image
          env:
            IMAGE_TAG: ${{ github.run_number }}
          run: |
            echo "ðŸ”§ Building Docker image..."
            docker build -t $ECR_REPO:$IMAGE_TAG $APP_DIR
            echo "Tagging image for ECR..."
            ECR_URI="${{ steps.login-ecr.outputs.registry }}/$ECR_REPO:$IMAGE_TAG"
            docker tag $ECR_REPO:$IMAGE_TAG $ECR_URI
            echo "Pushing image to ECR..."
            docker push $ECR_URI
            echo "IMAGE_URI=$ECR_URI" >> $GITHUB_ENV
            echo "Image pushed: $ECR_URI"
      
        - name: Update kubeconfig for EKS
          run: aws eks update-kubeconfig --region $AWS_REGION_1 --name $CLUSTER_NAME

        - name: Update image in Kubernetes deployment file
          run: |
            echo "Updating image in $NODE_DEPLOYMENT_FILE"
            sed -i "s|image: .*|image: ${IMAGE_URI}|g" $NODE_DEPLOYMENT_FILE
            echo "Updated deployment image to: ${IMAGE_URI}"

        - name: Deploy updated Node app to EKS
          run: |
            echo "Applying Node.js deployment to EKS..."
            kubectl apply -f $NODE_DEPLOYMENT_FILE -n $NAMESPACE_1
            # kubectl rollout status deployment/my-node-app -n $NAMESPACE_1 --timeout=120s
            echo "Node app deployed successfully!"

    
        # - name: Update deployment image to new tag
        #   shell: bash
        #   run: |
        #     IMAGE_URI="${{ needs.push_to_ecr.outputs.pushed_tag }}"
        #     echo "Using image: $IMAGE_URI"
        #     sed -i "s|image: .*|image: ${IMAGE_URI}|g" "$NODE_DEPLOYMENT_FILE"
        #     echo "Patched $NODE_DEPLOYMENT_FILE with $IMAGE_URI"
    
        # - name: Deploy updated Node app to EKS
        #   run: |
        #     echo "Applying Node.js deployment to EKS..."
        #     kubectl apply -f "$NODE_DEPLOYMENT_FILE" -n "$NAMESPACE_1"
        #     kubectl rollout status deployment/my-node-app -n "$NAMESPACE_1" --timeout=180s || true
        #     echo "Node app deployed (or rollout check skipped)."
    
        - name: Get ZAP Pod details
          shell: bash
          run: |
            kubectl get pods -n "$NAMESPACE_1"
            kubectl get pods -n "$NAMESPACE_2"
            kubectl get pods -n "$NAMESPACE_1" --show-labels
            POD_NAME=$(kubectl get pods -n "$NAMESPACE_1" -l app=zap -o jsonpath='{.items[0].metadata.name}')
            echo "POD_NAME=$POD_NAME" >> $GITHUB_ENV
            echo "Pod name found: $POD_NAME"
    
        - name: Copy files into ZAP pod
          run: |
            kubectl cp zap.yaml "$POD_NAME:/zap/wrk/zap.yaml" -n "$NAMESPACE_1"
            kubectl cp swagger1.json "$POD_NAME:/zap/swagger.json" -n "$NAMESPACE_1"
            kubectl cp 1.yaml "$POD_NAME:/zap/2.yaml" -n "$NAMESPACE_1"
    
        - name: Run ZAP scan inside pod (non-fatal)
          run: |
            echo "Running ZAP scan inside pod: $POD_NAME"
            kubectl exec -n "$NAMESPACE_1" "$POD_NAME" -- pwd || true
            kubectl exec -n "$NAMESPACE_1" "$POD_NAME" -- ls /zap/reports || true
            kubectl exec -n "$NAMESPACE_1" "$POD_NAME" -- bash -c "/zap/zap.sh -cmd -autorun /zap/wrk/zap.yaml -config dir.home=/zap/wrk -config dir.report=/zap/reports -config api.disablekey=true -config api.addrs.addr.name=.* -config api.addrs.addr.regex=true" || true
    
        - name: Copy ZAP report from pod to runner
          run: |
            kubectl cp "$NAMESPACE_1/$POD_NAME:/zap/reports/zap_api_report.html" ./zap_api_report.html || (echo "No report found" && exit 0)
            ls -lh zap_api_report.html || true
    
        - name: Upload ZAP report as artifact
          uses: actions/upload-artifact@v4
          with:
            name: zap-api-report
            path: zap_api_report.html
            retention-days: 5

        - name: Open report automatically (local use)
          if: runner.os == 'Linux'
          run: |
            xdg-open zap_api_report.html || true
    
        - name: Print Artifact Download URL
          run: |
            echo "ZAP Report successfully uploaded."
            echo "Open: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}#artifacts"
    
